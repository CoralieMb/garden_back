from flask_restful import Resource, fields, marshal as flask_marshall
from http import HTTPStatus
from garden_api.utils.rest_utils import entity_not_found_response
from garden_api.models import db, Exploitant as ExploitantEntity
from flask import request
from sqlalchemy import func


def marshal(entity: ExploitantEntity):
    resource_fields = {
        "id": fields.Integer(attribute="id_exploitant"),
        "libelle_long": fields.String(attribute="lib_exploitant_long"),
        "libelle_court": fields.String(attribute="lib_exploitant_court"),
        "etat": fields.Integer,
        "role": {
            "role": fields.Integer(attribute="role"),
            "libelle": fields.String(attribute="exploitant_role.libelle_role")
        }}
    return flask_marshall(entity, resource_fields)


def unmarshal(json):
    entity = ExploitantEntity()
    entity.id_exploitant = json.get('id')
    entity.lib_exploitant_long = json.get('libelle_long')
    entity.lib_exploitant_court = json.get('libelle_court')
    entity.etat = json.get('etat')
    entity.role = json.get(
        'role', {}).get("role")
    return entity


def validate_save(exploitant: ExploitantEntity):
    # common save validations for add and update
    # not common save validations must be performed in post() and put() functions
    if not exploitant.lib_exploitant_long:
        return "Libélle long obligatoire"

    if not exploitant.lib_exploitant_court:
        return "Libelle court est obligatoire"

    if not exploitant.role:
        return "Le rôle est obligatoire"

    return None


class Exploitant(Resource):
    def get(self, id_exploitant):
        exploitant = db.session.get(ExploitantEntity, id_exploitant)
        if (exploitant is None):
            return entity_not_found_response(id_exploitant)
        else:
            return marshal(exploitant)
    
    def put(self, id_exploitant):
        try:
            exploitant = unmarshal(request.json)

            if id_exploitant != exploitant.id_exploitant:
                return "ids in url and body not matching", HTTPStatus.BAD_REQUEST

            validation_error = validate_save(exploitant)
            if validation_error is not None:
                return validation_error, HTTPStatus.BAD_REQUEST

            exploitant_existante = db.session.query(ExploitantEntity).filter(
                (ExploitantEntity.id_exploitant != exploitant.id_exploitant) &
                ((func.lower(ExploitantEntity.lib_exploitant_long) == func.lower(exploitant.lib_exploitant_long)) |
                 (func.lower(ExploitantEntity.lib_exploitant_court) == func.lower(exploitant.lib_exploitant_court)))).first()

            if exploitant_existante:
                # if exploitant short or long name exists return error
                msg = 'L\'exploitant existe déjà à l\'état ' + \
                    ('Actif' if (exploitant_existante.etat == 1) else (
                        'Inactif' if (exploitant_existante.etat == 0) else ''))
                return msg, HTTPStatus.BAD_REQUEST

            exploitant_to_update = db.session.get(
                ExploitantEntity, id_exploitant)
            if exploitant_to_update is None:
                return entity_not_found_response(id_exploitant)
            else:
                for column in ExploitantEntity.__table__.columns:
                    setattr(exploitant_to_update, column.key,
                            getattr(exploitant, column.key))
                db.session.commit()
                return marshal(exploitant_to_update)

        except Exception as e:
            print(e)
            return'Echec de la mise à jour', HTTPStatus.INTERNAL_SERVER_ERROR

class Exploitants(Resource):

    # GET all the exploitant table

    def get(self):
        try:
            exploitant_request = db.session.query(ExploitantEntity)
            response_data = []

            for exploitant_item in exploitant_request:
                response_data.append(marshal(exploitant_item))
            return response_data

        except Exception as e:  # Exception = all native exceptions which do not get out of the systeme
            print(e)
            return None, HTTPStatus.INTERNAL_SERVER_ERROR

    # (POST) : add exploitant

    def post(self):
        try:
            exploitant = unmarshal(request.json)

            validation_error = validate_save(exploitant)

            if validation_error:
                return validation_error, HTTPStatus.BAD_REQUEST

            if exploitant.etat != 1:
                exploitant.etat = 1  # The exploitant must be active to the creation

                # we check if the long or short label already exists
                exploitant_existante = db.session.query(ExploitantEntity).filter(
                    (func.lower(ExploitantEntity.lib_exploitant_long) == func.lower(exploitant.lib_exploitant_long)) |
                    (func.lower(ExploitantEntity.lib_exploitant_court) == func.lower(exploitant.lib_exploitant_court))).first()

            if exploitant_existante:
                # if exploitant short or long name exists return error
                msg = 'L\'exploitant existe déjà à l\'état ' + \
                    ('Actif' if (exploitant_existante.etat == 1) else (
                        'Inactif' if (exploitant_existante.etat == 0) else ''))
                return msg, HTTPStatus.BAD_REQUEST
            else:
                db.session.add(exploitant)
                db.session.commit()
                return marshal(exploitant)

        except Exception as e:
            print(e)
            return 'Echec de l\'ajout de l\'exploitant', HTTPStatus.INTERNAL_SERVER_ERROR

    # PUT : update exploitant

class ExploitantCount(Resource):
    def get(self):
        return db.session.query(ExploitantEntity.id_exploitant).count()
